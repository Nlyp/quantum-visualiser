<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Visualizer: Bloch, Circuits & Hydrogen Atom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Three.js for 3D rendering -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
      }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
            color: #d1d5db; /* Light gray text */
        }
        .content-section {
            background-color: #1f2937;
            border: 1px solid #374151;
        }
        select, button, input[type="range"], input[type="number"] {
            background-color: #374151;
            color: #d1d5db;
            border: 1px solid #4b5563;
            transition: background-color: 0.2s;
        }
        button:hover:not(:disabled) {
            background-color: #4b5563;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #hydrogenCanvas, .bloch-canvas-container {
            background-color: #0f172a; 
            border-radius: 0.5rem;
            border: 1px solid #374151;
        }
        .bloch-canvas { cursor: grab; }
        .bloch-canvas:active { cursor: grabbing; }
        #measurement-stream {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            background-color: #0f172a;
            padding: 0.5rem;
            border-radius: 0.25rem;
            min-height: 80px;
            border: 1px solid #374151;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">

        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Quantum Visualizer</h1>
            <p class="text-lg text-cyan-400">An Interactive Journey into Quantum Mechanics</p>
        </header>

        <!-- Hydrogen Atom Introduction Section -->
        <section class="p-6 rounded-lg mb-8 content-section">
            <h2 class="text-2xl font-bold text-white mb-4">Hydrogen Atom Superposition</h2>
            <p class="mb-4">
                When an electron is in a superposition of two different orbitals (e.g., 1s and 2s), its probability cloud is no longer static. It exhibits a dynamic, time-dependent "breathing" motion.
            </p>
        </section>
        
        <!-- Hydrogen Atom Interactive Box -->
        <section class="p-6 rounded-lg  mb-8 content-section">
            <h2 class="text-2xl font-bold text-white mb-4">Visualize an Electron's Quantum Movie</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                <div class="flex flex-col">
                    <label for="orbital1" class="mb-1 text-sm font-medium">Select Orbital 1:</label>
                    <select id="orbital1" class="p-2 rounded-md">
                        <option value="1s">1s</option>
                        <option value="2s" selected>2s</option>
                        <option value="2p">2p</option>
                        <option value="3s">3s</option>
                        <option value="3p">3p</option>
                        <option value="3d">3d</option>
                        <option value="4s">4s</option>
                        <option value="4p">4p</option>
                        <option value="4d">4d</option>
                        <option value="4f">4f</option>
                    </select>
                </div>
                <div class="flex flex-col">
                    <label for="orbital2" class="mb-1 text-sm font-medium">Select Orbital 2:</label>
                    <select id="orbital2" class="p-2 rounded-md">
                        <option value="1s" selected>1s</option>
                        <option value="2s">2s</option>
                        <option value="2p">2p</option>
                        <option value="3s">3s</option>
                        <option value="3p">3p</option>
                        <option value="3d">3d</option>
                        <option value="4s">4s</option>
                        <option value="4p">4p</option>
                        <option value="4d">4d</option>
                        <option value="4f">4f</option>
                    </select>
                </div>
                <button id="visualizeBtn" class="p-2 rounded-md bg-cyan-600 hover:bg-cyan-700 text-white font-bold h-10">
                    Visualize
                </button>
                 <button id="explainHydrogenBtn" class="p-2 rounded-md bg-purple-600 hover:bg-purple-700 text-white font-bold h-10 flex items-center justify-center">
                    ✨ Explain the Physics
                </button>
            </div>
            <div class="mt-6">
                <canvas id="hydrogenCanvas" width="800" height="450"></canvas>
            </div>
        </section>

        <!-- Bloch Sphere by Amplitudes Section -->
        <section class="p-6 rounded-lg mb-8 content-section">
            <h2 class="text-2xl font-bold text-white mb-4">Defining a Qubit with Amplitudes</h2>
            <p class="mb-4">A qubit state **|ψ⟩ = a₀|0⟩ + a₁|1⟩** is defined by its amplitudes. Since |a₀|² + |a₁|² must equal 1, we can define the whole state just by setting **a₀**. Use the slider to set a₀ and see how a₁ is automatically calculated.</p>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                <div class="w-full aspect-square relative bg-[#0f172a] rounded-lg border border-[#374151] bloch-canvas-container">
                   <canvas id="bloch_canvas_amp" class="bloch-canvas"></canvas>
                </div>
                <div class="space-y-6">
                     <div>
                        <label for="a0-slider" class="text-sm font-medium">Amplitude a₀: <span id="a0-value">0.71</span></label>
                        <input id="a0-slider" type="range" min="-1" max="1" value="0.707" step="0.01" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="p-3 bg-gray-900 rounded-md border border-gray-700">
                        <h3 class="text-md font-semibold text-white mb-2">Calculated Amplitude a₁</h3>
                        <p id="a1-display" class="text-lg text-cyan-300 font-mono text-center">a₁ = 0.71</p>
                    </div>
                    <div class="p-3 bg-gray-900 rounded-md border border-gray-700">
                        <h3 class="text-md font-semibold text-white mb-2">Quantum State |ψ⟩</h3>
                        <p id="ket-vector" class="text-lg text-cyan-300 font-mono text-center">|ψ⟩ = ...</p>
                    </div>
                    <div class="p-3 bg-gray-900 rounded-md border border-gray-700">
                        <h3 class="text-md font-semibold text-white mb-2">Theoretical Measurement Probability</h3>
                        <div class="space-y-2">
                            <div>
                                <span class="text-sm">Prob(|0⟩):</span>
                                <div class="w-full bg-gray-700 rounded-full h-4">
                                    <div id="prob0-bar" class="bg-blue-500 h-4 rounded-full text-xs text-center text-white" style="width: 50%;">50%</div>
                                </div>
                            </div>
                            <div>
                                <span class="text-sm">Prob(|1⟩):</span>
                                <div class="w-full bg-gray-700 rounded-full h-4">
                                    <div id="prob1-bar" class="bg-purple-500 h-4 rounded-full text-xs text-center text-white" style="width: 50%;">50%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Qubit Measurement Section -->
        <section class="p-6 rounded-lg mb-8 content-section">
            <h2 class="text-2xl font-bold text-white mb-4">Qubit Measurement Simulator</h2>
            <p class="mb-4">Quantum measurement is probabilistic. When we measure a qubit in a superposition, it "collapses" to either 0 or 1. This simulator runs 100 measurements on the qubit you defined above. Watch the state vector collapse to |0⟩ (up) or |1⟩ (down) for each measurement.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="w-full aspect-square relative bloch-canvas-container">
                    <canvas id="bloch_canvas_measurement" class="bloch-canvas"></canvas>
                </div>
                <div>
                     <button id="run-measurement-btn" class="p-2 w-full rounded-md bg-cyan-600 hover:bg-cyan-700 text-white font-bold h-10 flex items-center justify-center mb-4">
                        Run Measurement (100 Shots)
                    </button>
                    <h3 class="font-semibold mb-2">Measurement Stream:</h3>
                    <div id="measurement-stream"></div>
                    <div class="w-full bg-gray-700 rounded-full h-2.5 mt-2">
                        <div id="measurement-progress" class="bg-cyan-400 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div class="mt-4">
                        <h3 class="font-semibold mb-2">Experimental Results:</h3>
                        <div class="space-y-2">
                            <p>Total |0⟩ state measured: <span id="zeros-count" class="font-bold text-blue-400">0</span></p>
                            <p>Total |1⟩ state measured: <span id="ones-count" class="font-bold text-purple-400">0</span></p>
                            <div>
                                <span class="text-sm">Experimental Prob(|0⟩):</span>
                                <div class="w-full bg-gray-700 rounded-full h-4">
                                    <div id="exp-prob0-bar" class="bg-blue-500 h-4 rounded-full text-xs text-center text-white" style="width: 0%;">0%</div>
                                </div>
                            </div>
                            <div>
                                <span class="text-sm">Experimental Prob(|1⟩):</span>
                                <div class="w-full bg-gray-700 rounded-full h-4">
                                    <div id="exp-prob1-bar" class="bg-purple-500 h-4 rounded-full text-xs text-center text-white" style="width: 0%;">0%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Quantum Circuit Section -->
        <section class="p-6 rounded-lg mb-8 content-section">
            <h2 class="text-2xl font-bold text-white mb-4">Single-Qubit Circuit Simulator</h2>
            <p class="mb-4">A quantum circuit manipulates qubits using quantum gates. Below, use the slider to define an initial qubit state on the Input Bloch Sphere employing equation, cos(theta)|0⟩ + exp(iphi)sin(theta)|1⟩ = 1. Then, select a quantum gate and press "Apply Gate" to see how it transforms the state on the Output Bloch Sphere.</p>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Input State -->
                <div class="text-center">
                    <h3 class="font-bold text-lg text-white mb-2">Input State |ψ⟩</h3>
                    <div class="w-full aspect-square relative bloch-canvas-container">
                        <canvas id="bloch_canvas_input" class="bloch-canvas"></canvas>
                    </div>
                    <div class="mt-4 space-y-2">
                         <div>
                            <label for="theta-slider" class="text-sm font-medium">Polar Angle (θ): <span id="theta-value">0</span>°</label>
                            <input id="theta-slider" type="range" min="0" max="180" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="phi-slider" class="text-sm font-medium">Azimuthal Angle (φ): <span id="phi-value">0</span>°</label>
                            <input id="phi-slider" type="range" min="0" max="360" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div>
                <!-- Output State -->
                 <div class="text-center">
                    <h3 class="font-bold text-lg text-white mb-2">Output State G|ψ⟩</h3>
                     <div class="w-full aspect-square relative bloch-canvas-container">
                        <canvas id="bloch_canvas_output" class="bloch-canvas"></canvas>
                    </div>
                    <div class="mt-4 p-3 bg-gray-900 rounded-md border border-gray-700">
                        <h3 class="text-md font-semibold text-white mb-2">Output State Vector</h3>
                        <p id="ket-vector-output" class="text-sm text-cyan-300 font-mono text-center">|ψ'⟩ = 1.00|0⟩ + 0.00|1⟩</p>
                    </div>
                </div>
            </div>

            <!-- Circuit Controls -->
            <div class="flex items-center justify-center space-x-4 p-4 rounded-lg bg-gray-900 border border-gray-700 my-4">
                <span class="font-mono text-xl text-cyan-400">|ψ⟩</span>
                 <div class="h-0.5 w-16 bg-gray-400"></div>
                 <select id="gate-select" class="p-2 rounded-md w-24 text-center font-bold">
                     <option value="X">X Gate</option>
                     <option value="Y">Y Gate</option>
                     <option value="Z">Z Gate</option>
                     <option value="H">H Gate</option>
                     <option value="S">S Gate</option>
                     <option value="Sdg">S† Gate</option>
                     <option value="T">T Gate</option>
                 </select>
                 <div class="h-0.5 w-16 bg-gray-400"></div>
                 <button id="apply-gate-btn" class="p-2 rounded-md bg-cyan-600 hover:bg-cyan-700 text-white font-bold">Apply Gate</button>
                 <div class="h-0.5 w-16 bg-gray-400"></div>
                 <span class="font-mono text-xl text-green-400">|ψ'⟩</span>
            </div>
            <button id="explain-gate-btn" class="p-2 w-full rounded-md bg-purple-600 hover:bg-purple-700 text-white font-bold h-10 flex items-center justify-center mt-4">
                ✨ Explain This Operation
            </button>
        </section>

        <!-- Gemini Explanation Section -->
        <section id="explanation-section" class="p-6 rounded-lg mt-8 content-section hidden">
            <h2 class="text-2xl font-bold text-white mb-4">✨ Physics Explained by Gemini</h2>
            <div id="explanation-content">
                <div id="loading-spinner" class="flex justify-center items-center h-24 hidden">
                    <svg class="animate-spin h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
                <p id="explanation-text" class="text-gray-300 leading-relaxed"></p>
            </div>
        </section>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // --- Shared Gemini Logic ---
        const explanationSection = document.getElementById('explanation-section');
        const loadingSpinner = document.getElementById('loading-spinner');
        const explanationText = document.getElementById('explanation-text');

        async function getGeminiExplanation(userQuery) {
            // ... (rest of Gemini logic)
        }
        
        // FIXED: Moved createLabel to a shared scope so all Bloch Spheres can use it
        function createLabel(text, position, color = 'white', size = 24) {
            const canvasEl = document.createElement('canvas');
            const context = canvasEl.getContext('2d');
            context.font = `${size}px Inter`;
            const width = context.measureText(text).width;
            canvasEl.width = width;
            canvasEl.height = size * 1.2;
            context.font = `${size}px Inter`;
            context.fillStyle = color;
            context.fillText(text, 0, size);
            const texture = new THREE.CanvasTexture(canvasEl);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.copy(position);
            sprite.scale.set(width / 100, (size * 1.2) / 100, 1);
            return sprite;
        }

        // --- Shared Bloch Sphere Rendering Logic ---
        function createBlochSphere(canvas) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            camera.position.z = 2.8;

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            const sphereGeom = new THREE.SphereGeometry(1, 32, 16);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1, wireframe: true });
            scene.add(new THREE.Mesh(sphereGeom, sphereMat));

            const axisLength = 1.4;
            const zAxis_blue = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -axisLength, 0), axisLength*2, 0x7777ff, 0.05, 0.1);
            const xAxis_red = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(-axisLength, 0, 0), axisLength*2, 0xff7777, 0.05, 0.1);
            const yAxis_green = new THREE.ArrowHelper(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, axisLength), axisLength*2, 0x77ff77, 0.05, 0.1); 
            scene.add(xAxis_red, yAxis_green, zAxis_blue);
            
            scene.add(createLabel('x', new THREE.Vector3(1.5, 0, 0), '#ff7777'));
            scene.add(createLabel('y', new THREE.Vector3(0, 0, -1.5), '#77ff77'));
            scene.add(createLabel('z', new THREE.Vector3(0, 1.5, 0), '#7777ff'));

            const stateVector = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1, 0xffff00, 0.1, 0.07);
            scene.add(stateVector);

            function onWindowResize() {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                renderer.setSize(size, size);
                camera.aspect = 1;
                camera.updateProjectionMatrix();
            }
            window.addEventListener('resize', onWindowResize);
            onWindowResize();

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            return { stateVector, scene };
        }

        // --- Amplitude Bloch Sphere Logic ---
        const ampCanvas = document.getElementById('bloch_canvas_amp');
        if (ampCanvas) {
            const a0Slider = document.getElementById('a0-slider');
            const a0Value = document.getElementById('a0-value');
            const a1Display = document.getElementById('a1-display');
            const ketVector = document.getElementById('ket-vector');
            const prob0Bar = document.getElementById('prob0-bar');
            const prob1Bar = document.getElementById('prob1-bar');
            
            const { stateVector } = createBlochSphere(ampCanvas);
            let currentProb0 = 0.5; 

            function updateBlochFromA0() {
                let a0 = parseFloat(a0Slider.value);
                a0Value.textContent = a0.toFixed(2);
                
                let a1 = Math.sqrt(1 - a0**2);
                a1Display.textContent = `a₁ = ${a1.toFixed(2)}`;
                
                ketVector.textContent = `|ψ⟩ = ${a0.toFixed(2)}|0⟩ + ${a1.toFixed(2)}|1⟩`;
                
                let theta_rad = 2 * Math.acos(a0);
                let phi_rad = 0;
                
                const x = Math.sin(theta_rad) * Math.cos(phi_rad);
                const y = Math.cos(theta_rad);
                const z = Math.sin(theta_rad) * Math.sin(phi_rad);
                stateVector.setDirection(new THREE.Vector3(x, y, z));
                
                const prob0 = a0**2;
                currentProb0 = prob0; 
                const prob1 = a1**2;
                prob0Bar.style.width = `${prob0 * 100}%`;
                prob0Bar.textContent = `${(prob0 * 100).toFixed(0)}%`;
                prob1Bar.style.width = `${prob1 * 100}%`;
                prob1Bar.textContent = `${(prob1 * 100).toFixed(0)}%`;
            }
            a0Slider.addEventListener('input', updateBlochFromA0);
            updateBlochFromA0();
            window.getCurrentProb0 = () => currentProb0;
        }

        // --- Qubit Measurement Logic ---
        const measurementCanvas = document.getElementById('bloch_canvas_measurement');
        if (measurementCanvas) {
            const { stateVector: measurementVector } = createBlochSphere(measurementCanvas);
            const runMeasurementBtn = document.getElementById('run-measurement-btn');
            const streamDiv = document.getElementById('measurement-stream');
            const progressDiv = document.getElementById('measurement-progress');
            const zerosCount = document.getElementById('zeros-count');
            const onesCount = document.getElementById('ones-count');
            const expProb0Bar = document.getElementById('exp-prob0-bar');
            const expProb1Bar = document.getElementById('exp-prob1-bar');

            async function runMeasurementSimulation() {
                runMeasurementBtn.disabled = true;
                streamDiv.textContent = '';
                zerosCount.textContent = '0';
                onesCount.textContent = '0';
                progressDiv.style.width = '0%';
                expProb0Bar.style.width = '0%';
                expProb0Bar.textContent = '0%';
                expProb1Bar.style.width = '0%';
                expProb1Bar.textContent = '0%';

                let zeroResults = 0;
                let oneResults = 0;
                const totalShots = 100;
                const prob0 = window.getCurrentProb0();

                for (let i = 1; i <= totalShots; i++) {
                    const result = Math.random() < prob0 ? '0' : '1';
                    
                    if (result === '0') {
                        zeroResults++;
                        measurementVector.setDirection(new THREE.Vector3(0, 1, 0)); // Point up
                        streamDiv.innerHTML += `<span class="text-blue-400">${result}</span>`;
                    } else {
                        oneResults++;
                        measurementVector.setDirection(new THREE.Vector3(0, -1, 0)); // Point down
                        streamDiv.innerHTML += `<span class="text-purple-400">${result}</span>`;
                    }
                    
                    zerosCount.textContent = zeroResults;
                    onesCount.textContent = oneResults;

                    const p0 = (zeroResults / i) * 100;
                    const p1 = (oneResults / i) * 100;
                    expProb0Bar.style.width = `${p0}%`;
                    expProb0Bar.textContent = `${p0.toFixed(0)}%`;
                    expProb1Bar.style.width = `${p1}%`;
                    expProb1Bar.textContent = `${p1.toFixed(0)}%`;
                    
                    progressDiv.style.width = `${(i / totalShots) * 100}%`;
                    
                    await new Promise(res => setTimeout(res, 50)); // Delay for collapse visualization
                }
                runMeasurementBtn.disabled = false;
            }
            runMeasurementBtn.addEventListener('click', runMeasurementSimulation);
        }

        // --- Quantum Circuit Logic ---
        const inputCanvas = document.getElementById('bloch_canvas_input');
        const outputCanvas = document.getElementById('bloch_canvas_output');
        if (inputCanvas && outputCanvas) {
            const { stateVector: inputVector } = createBlochSphere(inputCanvas);
            const { stateVector: outputVector } = createBlochSphere(outputCanvas);

            const thetaSlider = document.getElementById('theta-slider');
            const phiSlider = document.getElementById('phi-slider');
            const thetaValue = document.getElementById('theta-value');
            const phiValue = document.getElementById('phi-value');
            const ketOutput = document.getElementById('ket-vector-output');
            const gateSelect = document.getElementById('gate-select');
            const applyBtn = document.getElementById('apply-gate-btn');
            const explainGateBtn = document.getElementById('explain-gate-btn');

            let inputState = { theta: 0, phi: 0 };

            function updateInputSphere() {
                inputState.theta = (thetaSlider.value / 180) * Math.PI;
                inputState.phi = (phiSlider.value / 360) * (2 * Math.PI);
                thetaValue.textContent = thetaSlider.value;
                phiValue.textContent = phiSlider.value;

                const x = Math.sin(inputState.theta) * Math.cos(inputState.phi);
                const y = Math.cos(inputState.theta);
                const z = Math.sin(inputState.theta) * Math.sin(inputState.phi);
                inputVector.setDirection(new THREE.Vector3(x, y, z));
            }
            
            thetaSlider.addEventListener('input', updateInputSphere);
            phiSlider.addEventListener('input', updateInputSphere);
            
            const gates = {
                X: [[0, 1], [1, 0]],
                Y: [[0, {real:0, imag:-1}], [{real:0, imag:1}, 0]],
                Z: [[1, 0], [0, -1]],
                H: [[1/Math.sqrt(2), 1/Math.sqrt(2)], [1/Math.sqrt(2), -1/Math.sqrt(2)]],
                S: [[1, 0], [0, {real:0, imag:1}]],
                Sdg: [[1, 0], [0, {real:0, imag:-1}]],
                T: [[1, 0], [0, {real:Math.cos(Math.PI/4), imag:Math.sin(Math.PI/4)}]]
            };

            function toComplex(c) {
                if (typeof c === 'number') return { real: c, imag: 0 };
                return c;
            }
            
            function applyGate() {
                const cosTheta2 = Math.cos(inputState.theta / 2);
                const sinTheta2 = Math.sin(inputState.theta / 2);
                
                const a0_in = { real: cosTheta2, imag: 0 };
                const a1_in = { 
                    real: sinTheta2 * Math.cos(inputState.phi), 
                    imag: sinTheta2 * Math.sin(inputState.phi)
                };

                const gateMatrix = gates[gateSelect.value];
                const G00 = toComplex(gateMatrix[0][0]);
                const G01 = toComplex(gateMatrix[0][1]);
                const G10 = toComplex(gateMatrix[1][0]);
                const G11 = toComplex(gateMatrix[1][1]);
                
                const term1_real = G00.real * a0_in.real - G00.imag * a0_in.imag;
                const term1_imag = G00.real * a0_in.imag + G00.imag * a0_in.real;
                const term2_real = G01.real * a1_in.real - G01.imag * a1_in.imag;
                const term2_imag = G01.real * a1_in.imag + G01.imag * a1_in.real;
                const a0_out_real = term1_real + term2_real;
                const a0_out_imag = term1_imag + term2_imag;
                const term3_real = G10.real * a0_in.real - G10.imag * a0_in.imag;
                const term3_imag = G10.real * a0_in.imag + G10.imag * a0_in.real;
                const term4_real = G11.real * a1_in.real - G11.imag * a1_in.imag;
                const term4_imag = G11.real * a1_in.imag + G11.imag * a1_in.real;
                const a1_out_real = term3_real + term4_real;
                const a1_out_imag = term3_imag + term4_imag;

                const mag_a0_sq = a0_out_real**2 + a0_out_imag**2;
                const theta_out = 2 * Math.acos(Math.sqrt(mag_a0_sq));
                
                const phase_a0 = Math.atan2(a0_out_imag, a0_out_real);
                const phase_a1 = Math.atan2(a1_out_imag, a1_out_real);
                let phi_out = phase_a1 - phase_a0;

                const x_out = Math.sin(theta_out) * Math.cos(phi_out);
                const y_out = Math.cos(theta_out);
                const z_out = Math.sin(theta_out) * Math.sin(phi_out);
                outputVector.setDirection(new THREE.Vector3(x_out, y_out, z_out));

                function formatComplex(real, imag) {
                    if (Math.abs(real) < 0.01 && Math.abs(imag) < 0.01) return "0.00";
                    let parts = [];
                    if (Math.abs(real) >= 0.01) parts.push(real.toFixed(2));
                    if (Math.abs(imag) >= 0.01) {
                         if (parts.length > 0 && imag > 0) parts.push('+');
                         parts.push(`${imag.toFixed(2)}i`);
                    }
                    return parts.join(' ').replace('+ -', '- ');
                }
                
                const a0_out_str = formatComplex(a0_out_real, a0_out_imag);
                const a1_out_str = formatComplex(a1_out_real, a1_out_imag);
                
                ketOutput.textContent = `|ψ'⟩ = (${a0_out_str})|0⟩ + (${a1_out_str})|1⟩`;
            }

            applyBtn.addEventListener('click', applyGate);
            explainGateBtn.addEventListener('click', () => {
                const gateName = gateSelect.options[gateSelect.selectedIndex].text;
                const userQuery = `Act as a physics professor. In a concise, easy-to-understand paragraph, explain the purpose of a quantum ${gateName}. Describe how it transforms an initial qubit state defined by theta=${thetaSlider.value} and phi=${phiSlider.value} on the Bloch sphere.`;
                getGeminiExplanation(userQuery);
            });

            updateInputSphere();
            applyGate();
        }

        // --- Hydrogen Atom Logic ---
        const hydrogenCanvas = document.getElementById('hydrogenCanvas');
        if(hydrogenCanvas) {
            const ctx = hydrogenCanvas.getContext('2d');
            const visualizeBtn = document.getElementById('visualizeBtn');
            const orbital1Select = document.getElementById('orbital1');
            const orbital2Select = document.getElementById('orbital2');
            const explainHydrogenBtn = document.getElementById('explainHydrogenBtn');
            
            const hbar = 1; // Using atomic units
            
            const radialWavefunctions = {
                '1s': r => 2 * Math.exp(-r),
                '2s': r => (1/Math.sqrt(8)) * (2 - r) * Math.exp(-r/2),
                '2p': r => (1/Math.sqrt(24)) * r * Math.exp(-r/2),
                '3s': r => (2/81*Math.sqrt(3)) * (27 - 18*r + 2*r**2) * Math.exp(-r/3),
                '3p': r => (4/81*Math.sqrt(6)) * (6*r - r**2) * Math.exp(-r/3),
                '3d': r => (4/81*Math.sqrt(30)) * r**2 * Math.exp(-r/3),
                '4s': r => (1/4) * (1 - 3/4*r + 1/8*r**2 - 1/192*r**3) * Math.exp(-r/4),
                '4p': r => (Math.sqrt(5)/(16*Math.sqrt(3))) * (1 - 1/4*r + 1/80*r**2) * r * Math.exp(-r/4),
                '4d': r => (1/(64*Math.sqrt(5))) * (1 - 1/12*r) * r**2 * Math.exp(-r/4),
                '4f': r => (1/(768*Math.sqrt(35))) * r**3 * Math.exp(-r/4),
            };

            function parseState(stateStr) {
                const n = parseInt(stateStr[0], 10);
                return n;
            }

            function getEnergy(n) { return -0.5 / (n * n); }

            let animationFrameId;
            let time = 0;
            let orbital1 = '2s';
            let orbital2 = '1s';

            const r_max = 40, r_numPoints = 500;
            const r_values = Array.from({ length: r_numPoints }, (_, i) => (i / (r_numPoints - 1)) * r_max);
            
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const plotWidth = hydrogenCanvas.width - padding.left - padding.right;
            const plotHeight = hydrogenCanvas.height - padding.top - padding.bottom;

            function worldToCanvas(r, p) {
                const yMax = 0.5; 
                const canvasX = padding.left + (r / r_max) * plotWidth;
                const canvasY = padding.top + plotHeight - (p / yMax * plotHeight);
                return { x: canvasX, y: canvasY };
            }

            function drawAxes() {
                ctx.beginPath();
                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 1;
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, padding.top + plotHeight);
                ctx.moveTo(padding.left, padding.top + plotHeight);
                ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
                ctx.stroke();
                ctx.fillStyle = '#9ca3af';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let i = 0; i <= 5; i++) {
                    const val = (i * 0.1).toFixed(1);
                    const { y } = worldToCanvas(0, val);
                    ctx.fillText(val, padding.left - 30, y);
                }
                ctx.save();
                ctx.translate(padding.left - 45, hydrogenCanvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Radial Probability Density', 0, 0);
                ctx.restore();
                for (let i = 0; i <= 4; i++) {
                    const r = i * 10;
                    const { x } = worldToCanvas(r, 0);
                    ctx.fillText(r.toString(), x, padding.top + plotHeight + 15);
                }
                ctx.fillText('Radius (r) in Bohr radii', hydrogenCanvas.width / 2, padding.top + plotHeight + 30);
            }

            function animateHydrogen() {
                ctx.clearRect(0, 0, hydrogenCanvas.width, hydrogenCanvas.height);
                drawAxes();
                
                const n1 = parseState(orbital1);
                const n2 = parseState(orbital2);
                const E1 = getEnergy(n1);
                const E2 = getEnergy(n2);
                const R1 = radialWavefunctions[orbital1];
                const R2 = radialWavefunctions[orbital2];

                const radialProbDensity = r_values.map(r => {
                    const psi1_real = R1(r) * Math.cos(-E1 * time / hbar);
                    const psi1_imag = R1(r) * Math.sin(-E1 * time / hbar);
                    const psi2_real = R2(r) * Math.cos(-E2 * time / hbar);
                    const psi2_imag = R2(r) * Math.sin(-E2 * time / hbar);
                    const total_real = (psi1_real + psi2_real) / Math.sqrt(2);
                    const total_imag = (psi1_imag + psi2_imag) / Math.sqrt(2);
                    const psi_mag_sq = total_real**2 + total_imag**2;
                    return r**2 * psi_mag_sq; 
                });
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(220, 38, 38, 1)';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
                
                let firstPoint = worldToCanvas(r_values[0], 0);
                ctx.moveTo(firstPoint.x, firstPoint.y);

                for (let i = 0; i < r_values.length; i++) {
                    const { x, y } = worldToCanvas(r_values[i], radialProbDensity[i]);
                    ctx.lineTo(x, y);
                }
                let lastPoint = worldToCanvas(r_values[r_values.length - 1], 0);
                ctx.lineTo(lastPoint.x, lastPoint.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                time += 0.5; 
                animationFrameId = requestAnimationFrame(animateHydrogen);
            }

            function startHydrogenAnimation() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                time = 0;
                orbital1 = orbital1Select.value;
                orbital2 = orbital2Select.value;
                if (orbital1 === orbital2) {
                     alert("Please select two different orbitals for a dynamic superposition.");
                     ctx.clearRect(0, 0, hydrogenCanvas.width, hydrogenCanvas.height);
                     drawAxes();
                     const R = radialWavefunctions[orbital1];
                     const probDensity = r_values.map(r => r**2 * R(r)**2);
                     ctx.beginPath();
                     ctx.strokeStyle = 'rgba(220, 38, 38, 1)';
                     ctx.lineWidth = 2;
                     let firstPoint = worldToCanvas(r_values[0], probDensity[0]);
                     ctx.moveTo(firstPoint.x, firstPoint.y);
                     for (let i = 1; i < r_values.length; i++) {
                         const { x, y } = worldToCanvas(r_values[i], probDensity[i]);
                         ctx.lineTo(x, y);
                     }
                     ctx.stroke();
                     return;
                }
                animateHydrogen();
            }

            function getHydrogenExplanation() {
                const o1 = orbital1Select.value;
                const o2 = orbital2Select.value;
                const userQuery = `Act as a physics professor. In a concise, easy-to-understand paragraph, explain the physical significance of an electron in a Hydrogen atom being in a superposition of the ${o1} and ${o2} orbitals. Describe what the 'breathing' or 'pulsating' motion of the radial probability density represents physically.`;
                getGeminiExplanation(userQuery);
            }
            
            visualizeBtn.addEventListener('click', startHydrogenAnimation);
            explainHydrogenBtn.addEventListener('click', getHydrogenExplanation);
            startHydrogenAnimation();
        }
    </script>
</body>
</html>

